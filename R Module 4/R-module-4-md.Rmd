---
title: "R Module 4"
author: "GHY 5800"
output:
  pdf_document: default
  html_document:
    css: C:/Users/Harrison Brown/Documents/html_air_square/resources/air_square.css
---

```{=html}
<style>
body
  {text-align: justify}
  {font-size: 18px}
</style>
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      root.dir = "C:/RStudio/Projects/rmodule4/",
                      dev = "png",
                      dev.args = list(type = "cairo-png"))
library(sf)
library(dplyr)
library(ggplot2)
NC <- read_sf("C:/RStudio/Projects/rmodule4/NC_REGION.shp")
```

::: {style="text-align: left"}
# Descriptive Spatial Statistics
:::

Tabular and visual explorations of data are always an important first step to understanding the distribution of actual values across a range of possible outcomes. Frequency tables, bar plot, histograms, and box plots are basic tools for these tasks. Additionally, when we have *geospatial* data, mapping is a crucial tool.

These types of explorations have limits and we will also need actual measures of distributions of values across a range of possible outcomes, as well as across geographic space. For this, we rely on *measures of central tendency* and *measures of dispersion*.

------------------------------------------------------------------------

Let's start with a shapefile of manufacturing jobs in North Carolina. This shapefile has four different variables regarding employment:

-   Manufacturing jobs in the year 1990 (`MNEM1990`),

-   Manufacturing jobs in the year 2000 (`MNEM2000`),

-   Total jobs in 1990 (`TOTJO1990` -- note the typo in this data!), and,

-   Total jobs in 2000 (`TOTJOB1990`)

Using the `sf` (simple features) package, let's load in this shapefile. Before we begin, though, we need to set up our workspace. First, let's simply load `sf`:

```{r library, eval=FALSE, include=TRUE}
library(sf)
```

Part of our efforts will result in a new shapefile, so we need to tell R where to save files. We do this by setting the *working directory*, which allows us to load and save files without having to type out the full file path each time. When you do this, of course, type in the directory you'll actually be using. Note that backslash `\` is an "escape character" in R, so make sure you're using the right one.

```{r setwd, eval=FALSE, include=TRUE}
setwd("C:/example/directory/rmodule4/")

#or

setwd(choose.dir())
```

Now, let's finally load the file into our working directory. One of the easiest ways to do this is with the `file.choose()` function, which opens a window where you can navigate to your file. Navigate to where you downloaded the shapefile, and choose `NC_REGION.shp`.

```{r loadsf, eval=FALSE, include=TRUE}
NC <- read_sf(file.choose())
```

Take a look at `NC`. Notice how the last column, `geometry` (you may have to hit the `≫` button) appears to be a list of coordinates. Pretty neat! You can browse the data with `summary()` to get a measure of some of the descriptive statistics, such as mean, 1st and 3rd quartiles, and minimum and maximum values. We might like to add such basic descriptive statistics to a histogram of the variables as part of our data exploration.

### Plotting with `ggplot2`

Let's use the `ggplot2` library to help us make an aesthetically-pleasing histogram of manufacturing jobs in the year 2000.

```{r gghist}
library(ggplot2)
MNEM2000_hist <- ggplot(NC, aes(x = MNEM2000)) +
  geom_histogram(fill = "steelblue",
                 bins = nclass.FD(NC$MNEM2000),
                 boundary = 0)

MNEM2000_hist

```

The `nclass.FD` function calculates the 'ideal' number of classes based on the "Freedman-Diaconis" choice, based on the Inter-quartile range. The `boundary = 0` tells the plot to align the bins to the y-axis (0). Let's add a smoothed frequency curve to the histogram to show density...

```{r ggdensity}
MNEM2000_hist <- MNEM2000_hist + 
  geom_density(aes(y = ..scaled.. * 10),
               size = 1)
# The ..scaled.. represents the density curve scaled to a
# maximum of 1. We could just use geom_density(), but the curve
# is much smaller and less visible

# We also multiplied the height of the density curve by 10
# so it's more visible compared to our histogram!

MNEM2000_hist
```

We should also add lines showing mean and median

```{r gglabels}
MNEM2000_mean <- mean(NC$MNEM2000)
MNEM2000_median <- median(NC$MNEM2000)

MNEM2000_hist <- MNEM2000_hist +
  geom_vline(
    aes(xintercept = MNEM2000_mean, color = "Mean"),
      linetype = "dashed",
      size = 1) +
  geom_vline(
    aes(xintercept = MNEM2000_median, color = "Median"),
      linetype = "dashed",
      size = 1
  ) +
  scale_color_manual(name = "Statistics",
                     values = c(Mean = "salmon",
                                Median = "turquoise"))

MNEM2000_hist
```

Let's break down what we just did...

First, we assigned mean and median values of `MNEM2000` to their respective variables. Technically, we could do this all within the `geom_vline()` function (e.g. `aes(xintercept = mean(NC$MNEM2000)`), but this way will make it more organized when you create plots of different variables.

The `geom_vline()` function plots a **v**ertical **line**, and it's possible to assign an `xintercept` aesthetic mapping. "Median" and "Mean" obviously aren't colors, but we're telling our plot to use those as "placeholder" values that we define later, using `scale_color_manual()`. Additionally, we can set the size and linetype arguments. Normally, you can just define the color of a `geom_vline()` by saying something like `color = "blue"`, but this is how to do it if you want to have a legend describing each object.

Finally, we should add some labels and a title. Note that we could have used all of these ggplot functions in one 'section'; an example of this will show up in the last section of this R Module.

```{r gglabels2}
MNEM2000_hist <- MNEM2000_hist + 
  labs(title = "Descriptive Statistics of Manufacturing (2000)",
       x = "Manufacturing Jobs",
       y = "Count")

MNEM2000_hist
```

Not bad! A few things could use some work; we could change some colors, of course, but this'll do for the time being!

1.  **Create a histogram (using the `nclass.FD()` function) with frequency (`geom_density()`) curves, mean and median lines (`geom_vline()`), appropriate axis labels, and titles (`labs()`) for all four employment variables. Choose your own colors, font, etc.!**

If you want to arrange your four plots into a grid, refer to the **tips and tricks** section to see how to combine plots easily in ggplot.

------------------------------------------------------------------------

\pagebreak

## Visualizing spatial data with `sf`

We already know some important things about employment variables from reviewing visual and descriptive measures. For instance, we know that the data to the right of the mean have a lot of observations (a high value) for manufacturing in 2000. Since we know that this data is aggregated at the county level (the scale of our shapefile), this means the majority of North Carolina's 100 counties have far fewer manufacturing jobs than the mean for the state. In other words, we have an initial clue that jobs are distributed unevenly across the 100 counties.

This is a perfect test case for one of the descriptive spatial measures that you were introduced to -- the **Location Quotient** (LQ). Let's explore how evenly (or unevenly) jobs are distributed across the state's 100 counties. To do this, we'll use our shapefile and introduce a new technique in R by creating a custom function to calculate the LQ for each county in 2000.

Recall from our discussion that the LQ is a ratio of the frequency of something within a particular area to the total frequency across a larger set of such area. Applying this to our observations of manufacturing jobs in NC would result in a formula like this for each county:

::: {style="text-align: center; font-size: 24px"}
$\frac{\text{(manufacturing jobs in county)/(total jobs in county)}}{\text{(manufacturing jobs in state)/(total jobs in state)}}$
:::

The information that we need for the numerator of the LQ calculation is already in our shapefile (`MNEM2000` and `TOTJOB2000`). We need to do some preparation first to calculate the denominator.

We can do this in R by first calculating the statewide ratio of manufacturing jobs to total job, which can be done by taking the sum of the county-level values:

```{r totjob}
JOBRATE.2000 <- 
  sum(NC$MNEM2000)/sum(NC$TOTJOB2000)

JOBRATE.2000
```

Returning this new variable gives us an expected outcome of `0.1144246` -- that is, if manufacturing jobs were evenly distributed across North Carolina, then we'd expect manufacturing jobs to comprise roughly 11.4% of all jobs in a given county.

Now, we can calculate our LQ for each county by comparing it to `JOBRATE.2000`, but we need to add a new field to our shapefile's attribute table to hold the results. We'll create the field and populate it with the calculated LQ values.

In base R, this can be done with:

```{r lqbase}
NC$LQ2000 <-  
  (NC$MNEM2000/NC$TOTJOB2000) / JOBRATE.2000
```

...or equally using the package `dplyr`'s `mutate()` function and pipe operator (`%>%`) to be more advanced!

```{r lqdplyr}
library(dplyr)
NC <- NC %>%
  mutate(LQ2000 = (MNEM2000 / TOTJOB2000) / JOBRATE.2000)
```

Let's look at the results:

```{r summlq}
summary(NC$LQ2000)
```

We can actually use `sf` to write our results to a shapefile, or even a .csv for use in Excel! Let's try it, so we can email our shapefile to all our friends. Remember when we set our working directory with `setwd()`? Because we did that step, we don't have to include the entire file path now!

```{r writest, eval=FALSE, include=TRUE}
st_write(NC, "example.shp")
```

------------------------------------------------------------------------

#### Choropleth mapping with `ggplot2`

Let's take the results of our analysis and generate a choropleth map. If you want some color inspiration, try calling the `colors()` function, which prints a list of all the colors in base R. Anyways, the `scale_color_steps` and `scale_fill_steps` are useful for graduated (choropleth) mapping. Remember, in ggplot, *color* represents the line color, and *fill* defines the fill color. Let's get started! Rather than do everything in multiple steps, let's call our ggplot all in one function.

```{r choropleth}
LQ_2000_gg <- ggplot(data = NC, mapping = aes(fill = LQ2000)) +
  geom_sf() +
  scale_fill_steps(low = "snow",
                   high = "springgreen4",
                   n.breaks = 6) +
  labs(title = "Location Quotient for Manufacturing Jobs (2000)",
       fill = "LQ (2000)",
       caption = "(your name here)")

LQ_2000_gg
```

Awesome! Now you're ready to generate your own choropleth maps in R!

2.  **Create and provide a map of the Location Quotient of manufacturing jobs in both 1990 and 2000. Provide your R code for the 1990 map; showing how you calculated the LQ and created the map.**

3.  **Use the `st_write()` function to save NC to a shapefile where you can use it again later.**

4.  **Using your two LQ maps, provide a short description of how jobs are distributed across North Carolina's counties, and how this changed (if at all) from 1990 to 2000.**

Submit everything to Google Classroom!

------------------------------------------------------------------------

\pagebreak

### Tips and Tricks

Combining multiple plots in base R is a little tedious; you have to set parameters for how many rows and columns of plots you want, which can be tiresome when you're generating a lot of different plots. Fortunately, this becomes much easier when using ggplots, thanks to the `plot_grid()` function in the `cowplot` package. Assign your ggplot to a variable (`<-`) to keep things tidy! The `nrow` and `ncol` arguments are optional, and `plot_grid` can arrange plots automatically if needed.

```{r exampleplots, eval=T, include=F, message=F, warning=F}
example.1 <- ggplot(NC, aes(y = TOTJOB2000, x = MNEM2000)) + 
  geom_point(size = 1,
             color = "steelblue") +  
  theme(legend.position = "null") +
  theme_minimal() + 
  labs(x = "",
       y = "")

example.2 <- ggplot(NC, aes(y = TOTJO1990, x = MNEM1990)) + 
  geom_point(size = 1,
             color = "salmon") + 
  theme(legend.position = "null") +
  theme_minimal() +
  labs(x = "",
       y = "")

example.3 <- ggplot(NC, aes(x = MNEM2000))+
  geom_histogram(fill = "steelblue",
                 bins = nclass.FD(NC$MNEM2000),
                 boundary = 0) +
  theme_minimal() +
  labs(x = "",
       y = "")

example.4 <- ggplot(NC, aes(x = MNEM1990))+
  geom_histogram(fill = "salmon",
                 bins = nclass.FD(NC$MNEM1990),
                 boundary = 0) +
  theme_minimal() +
  labs(x = "",
       y = "")
```

```{r cowplot2, message=FALSE, warning=FALSE}
cowplot::plot_grid(
  plotlist = list(example.1, example.2, example.3, example.4)
  )
```
