---
title: "Probability and Confidence Intervals"
output:
  html_document:
      toc: true
      toc_float: true
      toc_collapsed: true
      toc_depth: 3
      number_sections: false
---


For this R module, we'll use `R` to simplify a somewhat complicated task -- creating confidence intervals around a point estimate of population parameters. For all the examples below, we'll keep things simple by assuming that the population parameters we're interested in is the population mean, and that the best (i.e., least biased and most efficient) point estimator of that parameter is the sample mean.

Before we get started, let's revisit the properties of the normal distribution: a symmetrical distribution around an expected value mean and a standard deviation. We can generate an example of this distribution in `R`:

```{r seq}

# This code generates 200 equally-spaced values between -4 and 4, which we'll
# use as the 'input values'

x <- seq(from = -4,
         to = 4,
         length = 200)

```

Next, we'll calculate the normal probability density of `x` using `dnorm()`. This calculates the likelihood that each value of `x` will be observed, and assigns it to the variable `y`. Note that we must specify the mean and standard deviation; we'll set them to 0 and 1, respectively. 

```{r y}
y <- dnorm(x = x,
           mean = 0,
           sd = 1)
```

We can plot these to see the classic "bell-shaped" curve. 
```{r plot_setup, include = FALSE}
library(cowplot)
library(gridGraphics)
library(grid)

# Maggie, this is just a roundabout way to get both a ggplot and base R plot beside each other; I don't expect anyone to use this kind of syntax :)

q <- qplot(
  x = x,
  y = y,
  geom = "line",
  color = I("red")
)

b <- ~{plot(x, y, type = "l", col = "red")} %>% 
  ggdraw()

```

```{r normplot, eval = F}

# qplot is a great function if you're more familiar with base R plot(), but can
# be used in tandem with ggplot functions.

qplot(
  x = x,
  y = y,
  geom = "line",
  
  # Don't worry too much about what the I() function does here, it's just a
  # qplot thing :)
  color = I("red")
)

# But if you want to keep it simple, you can plot with base R.

plot(x, y, type = "l", col = "red")

```

```{r plots, echo = F, fig.cap = "ggplot2 (left) vs base R (right)"}

cowplot::plot_grid(plotlist = list(q, b))

```

For normally distributed data, we can estimate the probability of observing a range of values by calculating the area under the curve that corresponds to those values. For example, consider the area under the curve below. What is the probability that any value of x will be $\leq 0$?

```{r area1, echo = FALSE}
ggplot(data.frame(x), aes(x)) +
  stat_function(
    fun = dnorm,
    xlim = c(-4, 0),
    geom = "area",
    fill = "royalblue4",
    alpha = 0.75
  ) +
  stat_function(fun = dnorm)
  
```

It should be 50% because the curve is symmetric, right? We can test this in `R` with `pnorm()`, which calculates the probability of a value occurring to the left of the input `q`:

```{r pnorm}
pnorm(q = 0,
      mean = 0,
      sd = 1)
```
Or, 50%. 

We could substitute a value for `q` and `pnorm()` would calculate the probability of that value (if you want, the "area under the curve" to the left of that value). But what if we want the probability for a specific range such as from -1 to +1 such as the figure below?


```{r area2, echo = FALSE}

ggplot(data.frame(x), aes(x)) +
  stat_function(
    fun = dnorm,
    xlim = c(-1, 1),
    geom = "area",
    fill = "royalblue4",
    alpha = 0.75
  ) +
  stat_function(fun = dnorm)
  

```



***

## Mutating data with `dplyr::mutate()`


### Adding columns programatically


***
***


# Probability and Confidence Intervals


## Central Limit Theorem

***

## Confidence Intervals



***
***

# Assignment
