<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Spatial Autocorrelation I</title>

<script src="site_libs/header-attrs-2.13/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<link rel="shortcut icon" href="logo.svg" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R Modules</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="https://brownhr.github.io">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li>
  <a href="about.html">
    <span class="fa fa-info"></span>
     
    About
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    R Modules
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="RModule1.html">R Module 1</a>
    </li>
    <li>
      <a href="RModule2.html">R Module 2</a>
    </li>
    <li>
      <a href="RModule3.html">R Module 3</a>
    </li>
    <li>
      <a href="RModule5.html">R Module 5</a>
    </li>
    <li>
      <a href="RModule6.html">R Module 6</a>
    </li>
    <li>
      <a href="RModule7.html">R Module 7</a>
    </li>
    <li>
      <a href="RModule8.html">R Module 8</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Spatial Autocorrelation I</h1>

</div>


<div id="introduction-to-spatial-autocorrelation"
class="section level1">
<h1>Introduction to Spatial Autocorrelation</h1>
<p>One of the most important laws in Geography is that things that are
closer to one-another are more likely to be related to each other; this
is Tobler’s first law of Geography:</p>
<pre><code>&gt; Everything is related to everything else, but near things are more related than distant things</code></pre>
<p>This law gives us a foundation for an extremely powerful statistical
tool – Spatial Autocorrelation. This measure assesses the amount of
“related-ness” that can be explained by spatial proximity. Our null
hypothesis, therefore, is that values occur randomly over space. To
reject this null hypothesis means that spatial proximity has some effect
on the observed values; think back to the results of R Module 7, and how
our residuals seemed to “cluster” in certain parts of the state.</p>
<p>Spatial autocorrelation can be measured in a number of ways; in this
module, we’ll lay the groundwork for the most widely-used statistic for
spatial autocorrelation for a continuous variable: <em>Moran’s I</em>.
This metric is a “global measure” – it is a single value that defines
the entire dataset.</p>
<p>Before we can jump into calculating the Moran’s I, we have a few
additional decisions and tasks to perform. This week, we’ll walk through
the setup for calculating Moran’s I, specifically:</p>
<ol style="list-style-type: decimal">
<li>The choice of neighborhood criterion, and,</li>
<li>The creation of the <em>spatial weights matrix</em></li>
</ol>
</div>
<div id="choosing-a-neighborhood-criterion" class="section level1">
<h1>Choosing a neighborhood criterion</h1>
<p>Moran’s I measures the correlation of a variable with itself across
space, based on some criteria about how far away from a given unit other
values will be compared. In other words, we have to define a
“neighborhood” around each spatial unit to form the basis for comparing
the value of a spatial unit with the values in its neighborhood.</p>
<p>Neighborhoods can be defined in a number of ways, but the two basic
choices are either a <em>distance-base</em> approach or a <em>common
boundary-based</em> approach. Distance-based approaches can work for
both point and areal (polygon) data, although we typically assign an
area to a point by calculating its centroid. Common boundary-based
approaches are specifically used for areal data, because points don’t
have “boundaries”.</p>
<div id="distance-based" class="section level2">
<h2>Distance-Based</h2>
<p>Distance-based approaches require you to specify some distance
“threshold” that will be used to define which points or centroids will
be classified as “neighbors” for the autocorrelation tests. The larger
the distance, the more neighbors we expect. The figure below illustrates
that concept. If we set a distance band at a distance of 1 around the
focal unit (the red point), we’ll only have one other point in the
neighborhood. If we increase the distance by 50% to 1.5, we’ll have two
points in the neighborhood. So we always have a challenge in front of
us: what distance do we use?</p>
<p><img src="img/R%20Module%208/distance-based.png" /></p>
</div>
<div id="boundary-based" class="section level2">
<h2>Boundary-Based</h2>
<p>For boundary-based approaches, however, we define neighbors slightly
differently. Instead of establishing a distance around a point and
including all poitns within that distance, neighbors are defined by
whether or not two areal units share boundaries. This can be done in
several ways, thinking about it like a chess board. If neighbors should
share 0-length boundaries (corners), we have a “Bishop’s case”
neighborhood; if we exclude 0-length boundaries but include boundaries
with length &gt; 1 (edges), we have a “Rook’s case” neighborhood.
Combining both cases, we have a “Queen’s case” neighborhood. Just as
before, we are challenged to define what counts as a ‘shared’
boundary.</p>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>Bishop’s Case</th>
<th>Rook’s Case</th>
<th>Queen’s Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="img/R%20Module%208/bishop.png" /></td>
<td><img src="img/R%20Module%208/rook.png" /></td>
<td><img src="img/R%20Module%208/queen.png" /></td>
</tr>
</tbody>
</table>
<hr />
</div>
</div>
<div id="spatial-weights-matrix" class="section level1">
<h1>Spatial Weights Matrix</h1>
<p>For either distance or boundary based approaches, we also have to
decide how to measure the connection between neighboring units. The most
common way is to use a binary measure. If a given spatial unit <span
class="math inline">\(i\)</span> is connected to a given spatial unit
<span class="math inline">\(j\)</span>, the connection between them
<span class="math inline">\(w_{ij}\)</span> equals <span
class="math inline">\(1\)</span>. If there is no connection, <span
class="math inline">\(w_{ij} = 0\)</span>. If we were to record all the
connections between all spatial units, we could record the results as a
matrix, where each row and column of the matrix is a list of spatial
units and each cell in the matrix is our binary measure of whether a
connection exists between those spatial units.</p>
<p>For example, if we have seven counties, <code>We</code>,
<code>Ad</code>, <code>Ar</code>, <code>De</code>, <code>Bo</code>,
<code>Je</code>, and <code>Do</code>, we can specify the connections
between each pair of counties using Queen’s case boundaries, and measure
those connections using a binary value. If we summarize this in matrix
form, we have a formal expression of connectivity based on our choices.
This is called the <strong>spatial weights matrix</strong>; you’ll find
it referred to in spatial autocorrelation formulas as <span
class="math inline">\(w_{ij}\)</span>, and looks like:</p>
<p><img src="img/R%20Module%208/example-swm.png" width="30%" style="display: block; margin: auto;" /></p>
</div>
<div id="working-with-the-data" class="section level1">
<h1>Working with the Data</h1>
<p>Let’s explore both of these steps using R. We’ll work again with our
manufacturing employment data for North Carolina. This week, you’ll need
to install another package, <code>spdep</code>, which you’ll use to
generate the spatial weights matrix for the global Moran’s I.</p>
<pre class="r"><code>library(sf)
library(spdep)


NC &lt;- read_sf(&quot;data/NC_REGION.shp&quot;)</code></pre>
<p>Whenever we perform any sort of spatial analysis in GIS, it’s
important to work in a <em>projected coordinate system</em>. Remember
how maps like the Mercator projection distort the Earth’s surface as it
approaches the poles? It’s a similar concept; instead of using
latitude/longitude coordinates, we need to work with a projected system
which gives us linear units.</p>
<p><code>sf</code> can reproject our data with the
<code>st_transform()</code> function, an argument of which is
<code>crs</code>, or <em>coordinate reference system</em>. We’ll use
something called the “EPSG code”, which is a unique identifier for each
coordinate reference system, such as Lambert Conformal Conic, UTM Zone
17N, etc. We’ll use <code>EPSG:26917</code> for our data, which we can
get some info about with <code>st_crs()</code>:</p>
<pre class="r"><code>st_crs(&quot;EPSG:26917&quot;)</code></pre>
<pre class="r"><code>class(st_crs(&quot;EPSG:26917&quot;))</code></pre>
<pre><code>## [1] &quot;crs&quot;</code></pre>
<p>Let’s transform our data:</p>
<pre class="r"><code># The &#39;crs&#39; argument works best when we give it an object of class &#39;crs&#39;, such
# as what&#39;s given by the st_crs() function
NC_UTM &lt;- st_transform(NC, crs = st_crs(&quot;EPSG:26917&quot;))</code></pre>
<p>If we plot our original vs. our transformed, hopefully we’ll see some
differences! Notice the northern border now appears slightly
“curved”:</p>
<pre class="r"><code>library(tmap)

# qtm() can be used to generate a &quot;quick thematic map&quot;, which is great for
# visualizing our data. Check it out with ?tmap::qtm()

t1 &lt;- qtm(NC)
t2 &lt;- qtm(NC_UTM)

tmap_arrange(t1, t2)</code></pre>
<p><img src="RModule8_files/figure-html/tranform-plot-1.png" width="80%" /></p>
<p>Let’s calculate the neighbor criterion with a boundary-based
approach, using the <code>spdep::poly2nb()</code> function. We’ll also
calculate the centroids of our counties.</p>
<pre class="r"><code>queen_nb &lt;- poly2nb(NC_UTM, queen = TRUE)

NC_centroids &lt;- st_centroid(NC_UTM)</code></pre>
<pre><code>## Warning in st_centroid.sf(NC_UTM): st_centroid assumes attributes are constant
## over geometries of x</code></pre>
<p>Let’s go ahead and also assign <code>NC_centroids$geometry</code> to
an object called <code>nc_coords</code>; we’ll use it a lot later!</p>
<pre class="r"><code>nc_coords &lt;- NC_centroids$geometry</code></pre>
<p>If we want to plot the lines, it’s easiest to use the
<code>nb2lines()</code> function, which generates an <code>sf</code>
object of the connections, allowing us to generate plots with
<code>tmap</code>, <code>ggplot2</code>, etc.</p>
<pre class="r"><code>nb_lines &lt;- nb2lines(nb = queen_nb,
                     coords = nc_coords)
tm_shape(NC_UTM) +
  tm_borders() +
  tm_shape(nb_lines) + tm_lines() +
  tm_shape(NC_centroids) + tm_dots(size = 0.125)</code></pre>
<p><img src="RModule8_files/figure-html/nb-lines-1.png" width="672" /></p>
<div id="questions" class="section level2">
<h2>Questions:</h2>
<p><strong>As in previous R Modules, type up your report as an R
Markdown document, and export it as a .pdf. Include your figures, plots,
and answers, and include your R code.</strong></p>
<ol style="list-style-type: decimal">
<li>Use the <code>poly2nb()</code> function to create a Rook’s case
neighbor construct by changing <code>queen = TRUE</code> to
<code>queen = FALSE</code>. Call this new object <code>rook_nb</code> in
your code. Plot a map using <code>tmap</code> that shows the counties,
the connections as lines, and the county centroids as points. Include a
title (hint: use <code>main.title</code> if you want to have the title
outside the map frame).</li>
</ol>
<hr />
<p>Notice how some counties have many neighbors and some have relatively
few. These constructs are sensitive to boundary effects; counties on the
edge of the study area will always have fewer connections, because
they’re not surrounded on all sides. We can get a helpful summary of the
distributions of connections between counties for the different
constructs we create.</p>
<pre class="r"><code>summary(queen_nb)</code></pre>
<pre><code>## Neighbour list object:
## Number of regions: 100 
## Number of nonzero links: 490 
## Percentage nonzero weights: 4.9 
## Average number of links: 4.9 
## Link number distribution:
## 
##  2  3  4  5  6  7  8  9 
##  8 15 17 23 19 14  2  2 
## 8 least connected regions:
## 4 21 45 56 77 80 90 99 with 2 links
## 2 most connected regions:
## 39 67 with 9 links</code></pre>
<p>This summary provides a great deal of information. Of particular
interest is the ‘link number distribution’ report: the top row of
numbers is the number of links, and the bottom is the number of counties
with that number of links. So, we have 8 counties with two links, 23
counties with five, 17 with four, etc. Because we didn’t tell
<code>poly2nb</code> what our counties were called, we can’t easily
locate these counties on the map.</p>
<p>There’s actually a bit of a bug with the
<code>poly2nb</code>function: the argument <code>row.names</code>
doesn’t work if we give it an object from <code>sf</code> (i.e., the
data we’ve been working on so far), so we have to have a bit of a
workaround if we want to assign the names:</p>
<pre class="r"><code>queen_names &lt;- NC_UTM %&gt;% 
  tibble::column_to_rownames(&quot;NAME&quot;) %&gt;% 
  st_as_sf() %&gt;% 
  poly2nb(pl = .,
          queen = TRUE)

summary(queen_names)</code></pre>
<pre><code>## Neighbour list object:
## Number of regions: 100 
## Number of nonzero links: 490 
## Percentage nonzero weights: 4.9 
## Average number of links: 4.9 
## Link number distribution:
## 
##  2  3  4  5  6  7  8  9 
##  8 15 17 23 19 14  2  2 
## 8 least connected regions:
## Currituck Chowan Tyrrell Dare Polk Pamlico Clay New Hanover with 2 links
## 2 most connected regions:
## Iredell Moore with 9 links</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Compare the distribution of links between the Queen’s case and
Rook’s case. What changed when we restricted the neighbor criterion by
using a Rook’s case? Using the code above, what are
<strong>names</strong> of the ‘least connected regions’ generated with a
Rook’s case neighborhood? Provide the code used to get your
results.</li>
</ol>
</div>
</div>
<div id="nearest-neighbor" class="section level1">
<h1>Nearest Neighbor</h1>
<p>To get around this type of problem, where some counties have very few
connections, we use a different method called <em>k-nearest
neighbor</em>. This method specifies the number of connections for each
spatial unit; for instance, when <span
class="math inline">\(k=1\)</span>, each spatial unit will have exactly
one neighbor. The choice for which unit becomes the neighbor is based on
distance between points or centroids; the unit that is “closest” is
classified as the neighbor.</p>
<p>Because we’re using a distance-based criteria, it’s good that we’ve
already projected our shapefile to a <code>crs</code> with linear units.
Let’s demonstrate a <span class="math inline">\(k = 1\)</span> setup
using the <code>knn2nb()</code> (<em>k-nearest neighbor to
neighbor-list</em>) function:</p>
<pre class="r"><code># We&#39;ll use the county name as the rownames. Unlike in poly2nb, the row.names
# argument actually seems to work :)

NC_knn1 &lt;- knn2nb(
  knn = knearneigh(x = NC_centroids,
                   k = 1),
  row.names = NC_UTM$NAME
)

# Now, let&#39;s make a plot. Remember, the nb2lines function is used to convert a
# neighbor list object into an &quot;sf-compatible&quot; object which we can map.

knn_lines &lt;- nb2lines(
  nb = NC_knn1,
  coords = nc_coords
)

qtm(NC_UTM, title = &quot;k = 1&quot;) +
  qtm(knn_lines) +
  qtm(NC_centroids)</code></pre>
<p><img src="RModule8_files/figure-html/knn-1-1.png" width="672" /></p>
<p>This is quite different to our Rook’s and Queen’s cases. Again, you
can use <code>summary()</code> to get the details of the connections
between spatial units. Doing this shows that the variability in the
distribution of connections is gone; all counties have exactly one
connection to another county.</p>
<div id="questions-1" class="section level2">
<h2>Questions</h2>
<ol start="3" style="list-style-type: decimal">
<li>In addition to <span class="math inline">\(k=1\)</span>, use
<code>knn2nb()</code> to create neighbor constructs for <span
class="math inline">\(k=2\)</span>, <span
class="math inline">\(k=4\)</span>, and <span
class="math inline">\(k=6\)</span>. Plot the connections for each using
<code>tmap</code>, including the label. Provide your R code and plots
for the neighbor constructs. Use <code>tmap_arrange()</code> to place
all 4 plots in a single “image”.</li>
</ol>
<ul>
<li><strong>Try and do this with some R programming; rather than just
generating each construct one-at-a-time, try using things like for
loops, <code>lapply</code>, <code>purrr::map</code> functions,
etc.</strong></li>
</ul>
</div>
</div>
<div id="distance-based-approach" class="section level1">
<h1>Distance-Based Approach</h1>
<p>For the final demonstration, let’s use a distance-based approach.
Rather than specifying a specific number of nearest neighbors, let’s
pick a distance threshold and apply it to every county. Any county
within this distance will be considered a neighbor. What distance should
we use for the threshold? Let’s explore this using the sets of distances
used for <span class="math inline">\(k=1\)</span> nearest neighbors.</p>
<p>First, we need to calculate the shortest distance between every
centroid:</p>
<pre class="r"><code>dist &lt;- nbdists(nb = NC_knn1,
                coords = nc_coords) %&gt;% 
  # We&#39;ll use the unlist() function to convert our list of distances to a vector, which is easier to compare.
  unlist()

summary(dist)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   12245   27152   29780   29427   32687   41087</code></pre>
<p>We can see that the maximum distance (in meters) between any of the
two counties is 41,087. If we set this as our distance band, we can be
sure that every county will have at least one neighbor.</p>
<p>Now, we can use <code>dnearneigh()</code> to create a distance-based
neighbor construct:</p>
<pre class="r"><code>max_dist &lt;- max(dist)

NC_dnn &lt;- dnearneigh(x = NC_centroids,
  d1 = 0,
  d2 = max_dist,
  row.names = NC_UTM$NAME
)

NC_dnn_sf &lt;- nb2lines(
  NC_dnn, coords = nc_coords
)

qtm(NC_UTM) + qtm(NC_dnn_sf)</code></pre>
<p><img src="RModule8_files/figure-html/dnn-1.png" width="672" /></p>
<p>It looks like it’s in between the Queen and Rook’s case, and the
<span class="math inline">\(k = 1\)</span> case. Again, you can call
<code>summary()</code> on <code>NC_dnn</code> to see the distribution of
the numbers of links.</p>
<p>We can also explore what happens as we increase or decrease the
distance threshold by modifying the <code>d2</code> argument, which
controls the “upper limit” of the distance-based neighbor.</p>
<div id="questions-2" class="section level2">
<h2>Questions:</h2>
<ol start="4" style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li>In addition to our “100%” distance threshold (the code above),
create plots for:</li>
</ol>
<ul>
<li>50% of the maximum distance,</li>
<li>125% of the maximum distance,</li>
<li>150% of the maximum distance.</li>
</ul>
<ol start="2" style="list-style-type: lower-alpha">
<li>Use <code>tmap</code> to do this, and arrange all plots in a single
image using <code>tmap_arrange()</code>. Be sure to label each
plot.</li>
<li>What happened to the number of connections from the 75% to the 125%
construct?</li>
</ol></li>
</ol>
</div>
</div>

<p>&copy; 2022 brownhr & M. Sugg. v.0.0.10</p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
