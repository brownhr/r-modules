<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Spatial Autocorrelation II</title>

<script src="site_libs/header-attrs-2.13/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<link rel="shortcut icon" href="logo.svg" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R Modules</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li>
  <a href="Syllabus.html">
    <span class="fa fa-file-text"></span>
     
    Syllabus
  </a>
</li>
<li>
  <a href="about.html">
    <span class="fa fa-info"></span>
     
    About
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    R Modules
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="RModule1.html">R Module 1</a>
    </li>
    <li>
      <a href="RModule2.html">R Module 2</a>
    </li>
    <li>
      <a href="RModule3.html">R Module 3</a>
    </li>
    <li>
      <a href="RModule5.html">R Module 5</a>
    </li>
    <li>
      <a href="RModule6.html">R Module 6</a>
    </li>
    <li>
      <a href="RModule7.html">R Module 7</a>
    </li>
    <li>
      <a href="RModule8.html">R Module 8</a>
    </li>
    <li>
      <a href="RModule9.html">R Module 9</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Spatial Autocorrelation II</h1>

</div>


<hr />
<div id="what-is-spatial-autocorrelation" class="section level1">
<h1>What is Spatial Autocorrelation?</h1>
<p>In the previous R Module, we introduced the idea of calculating a
“spatial neighborhood” and the need for a formal definition of this
neighborhood prior to spatial autocorrelation testing. Although these
constructs are relatively easy to make in R with the <code>spdep</code>
package, we have a lot of options; which method is best? Unfortunately,
there isn’t a single best method to use; it depends on the data you
have, the scale you’re looking at, and what you wish to accomplish.</p>
<p>Therefore, the results of spatial autocorrelation testing depend
heavily on the choices for your spatial neighborhood. The best recourse
is to first theorize the spatial form of the process you’re
investigating and to test several spatial neighbor constructs to see if
your results change significantly when your neighborhoods change.</p>
<div id="assigning-weights" class="section level2">
<h2>Assigning Weights</h2>
<p>Before we test spatial autocorrelation on our data, there’s another
step for us to perform after we create our neighbor constructs – our
spatial weights matrix <span class="math inline">\(W_{ij}\)</span>.
Recall from the previous Module that <span
class="math inline">\(W_{ij}\)</span> is an <span
class="math inline">\(n \times n\)</span> matrix, where <span
class="math inline">\(n\)</span> is the number of spatial units (points
or areas). The cells of the matrix record the presence or absence of
connections as a binary measure; <span class="math inline">\(0\)</span>
indicates no connection between the two units, and <span
class="math inline">\(1\)</span> indicates a connection.</p>
<p>We use binary measures because it’s often difficult to determine the
“relative influence” of spatial units on one another – North Carolina,
for example, borders both Virginia and Georgia, but its border with
Virginia is much longer. So, rather than guess the value, we start with
a binary measure; either there exists a connection or there doesn’t.</p>
<p>Suppose we had a study region that consisted of five counties and we
applied one of the neighborhood criteria from last R Module. Our <span
class="math inline">\(W_{ij}\)</span> would be a <span
class="math inline">\(5 \times 5\)</span> matrix, with cell values of
either <span class="math inline">\(0\)</span> or <span
class="math inline">\(1\)</span>, and might look something like
this:</p>
<p><img src="img/R%20Module%209/weights-matrix.png" width="40%" style="display: block; margin: auto;" /></p>
<div id="standardizing-weights" class="section level3">
<h3>Standardizing Weights</h3>
<p>Notice that some counties may have more or fewer connections than
others, meaning this wasn’t made with <span
class="math inline">\(k\)</span>-nearest neighbor. For example, county
<code>A</code> has 2 neighbors (we don’t count self-connections, so
<code>A</code>’s neighbors are <code>B</code> and <code>E</code>).
However, <code>E</code> has 3 neighbors: <code>A</code>, <code>C</code>,
and <code>D</code>. Because these connections are roughly analogous to
influence (counties with more connections likely have a greater
influence on the surrounding areas), we should set the total influence
upon a given unit to 1. In other words, we need to standardize the
connections, typically done by row standardizing.</p>
<p>To row standardize a matrix, we first sum each row, then divide each
non-zero cell in that row by the sum total:</p>
<p><img src="img/R%20Module%209/matrix-2.png" width="50%" style="display: block; margin: auto;" /></p>
<p>Row standardization splits the influence from neighboring units
proportionally. Put another way, row standardizing weights the influence
each county has on its neighbors proportionally and standardizes the
total influence on each spatial unit. There are other kinds of weighting
schemes but row standardization in commonly used, and is relatively easy
to perform in R. Once we’re done with this step, we can finally
calculate our global Moran’s I measure. To demonstrate, let’s return to
our data from the previous R Module.</p>
</div>
</div>
</div>
<div id="calculating-the-spatial-weights-matrix" class="section level1">
<h1>Calculating the Spatial Weights Matrix</h1>
<p>Load the required libraries and read in the shapefile to R.
Re-project the data to NAD 83 / UTM Zone 17N (please reference R Module
8), then use <code>poly2nb</code> to create a Queen’s case <span
class="math inline">\(W_{ij}\)</span>. After that, we’ll use the
<code>nb2listw()</code> function to row standardize our matrix.</p>
<pre class="r"><code>queen_nb_w &lt;- nb2listw(
  neighbours = queen_nb,
  # The default style, &quot;W&quot;, tells us that we&#39;re performing row standardization
  style = &quot;W&quot;,

  # Don&#39;t worry about this option for now, but it&#39;ll be important to include
  # later.
  zero.policy = TRUE,
)

summary(queen_nb_w)</code></pre>
<pre><code>## Characteristics of weights list object:
## Neighbour list object:
## Number of regions: 100 
## Number of nonzero links: 490 
## Percentage nonzero weights: 4.9 
## Average number of links: 4.9 
## Link number distribution:
## 
##  2  3  4  5  6  7  8  9 
##  8 15 17 23 19 14  2  2 
## 8 least connected regions:
## Currituck Chowan Tyrrell Dare Polk Pamlico Clay New Hanover with 2 links
## 2 most connected regions:
## Iredell Moore with 9 links
## 
## Weights style: W 
## Weights constants summary:
##     n    nn  S0       S1       S2
## W 100 10000 100 44.65023 410.4746</code></pre>
<p>Printing the new object itself doesnt show us our <span
class="math inline">\(W_{ij}\)</span> directly (technically it isn’t
stored as a matrix in R)</p>
<hr />
</div>
<div id="global-morans-i" class="section level1">
<h1>Global Moran’s I</h1>
<p>Moran’s I is a test of whether a variable autocorrelates with itself
across space. The calculation for Moran’s I is actually quite similar to
the Pearson’s <span class="math inline">\(r\)</span> correlation; the
main differences are that:</p>
<ol style="list-style-type: decimal">
<li>Moran’s I is a test of a single variable, and</li>
<li>Moran’s I requires us to first define our spatial weights matrix
<span class="math inline">\(W_{ij}\)</span></li>
</ol>
<p>We’ve done this already, so now we’re finally able to calculate
Moran’s I.</p>
<div id="what-does-i-represent" class="section level2">
<h2>What does <em>I</em> represent?</h2>
<p>The Moran’s I test returns a single value, ranging from <span
class="math inline">\(-1\)</span> to <span
class="math inline">\(1\)</span>, indicating “autocorrelation”. When
<span class="math inline">\(I = -1\)</span>, the variable in question is
perfectly “negatively spatially autocorrelated” – high values neighbor
low values – think about them like similar poles on bar magnets and how
they “want” to repel each other. When <span class="math inline">\(I =
1\)</span>, the variable in question is perfectly “positively spatially
autocorrelated” – high values “clump” together, as do low values.</p>
<p>What happens when <span class="math inline">\(I = 0\)</span>? This
indicates “spatial randomness” – sometimes high and low values occur,
sometimes they are dispersed, but there’s no systematic pattern
governing their distribution.</p>
<p>Mathematically, the calculation for <span
class="math inline">\(I\)</span> is as follows:</p>
<p><span class="math display">\[I = \frac{1}{s^2}\frac{
\sum_i\sum_j(y_i-\bar{y})(y_j-\bar{y}) }{ \sum_i\sum_j W_{ij} },
\]</span></p>
<p>With <span class="math display">\[s^2 = \frac{(\sum y_i
-\bar{y})^2}{n}\]</span></p>
<p>Let’s break this down:</p>
<ul>
<li><span class="math inline">\(s^2\)</span> is the sampling variances,
defined by the sum of the difference between each value and the mean,
then squared, and then divided by the number of spatial units <span
class="math inline">\(n\)</span>.</li>
<li>Our denominator is the total sum of all the cells in our spatial
weights matrix <span class="math inline">\(W_{ij}\)</span>.</li>
<li>The numerator is the sum of the differences in between <span
class="math inline">\(y_i\)</span> and <span
class="math inline">\(y_j\)</span> (the values in our rows and columns)
with our overall mean, <span
class="math inline">\(\bar{y}\)</span>.</li>
</ul>
<p>Hopefully, you won’t ever have to calculate this by hand, but it’s
important to see what the test is actually performing.</p>
<p>Because Moran’s I is a single value, it’s easy to interpret; it shows
the “global measure” of autocorrelation. However, actually calculating
the Moran’s I is somewhat difficult.</p>
<hr />
</div>
<div id="calculating-morans-i" class="section level2">
<h2>Calculating Moran’s I</h2>
<p>The real challenge in calculating Moran’s I is in creating the
sampling distribution that we need to find our critical values and our
<span class="math inline">\(p\)</span>-values used in hypothesis
testing. The safest assumption is that the statistical distribution (not
spatial distribution!) of our variable in question is not normal.
However, we can approximate a normal sampling distribution through
spatial randomization.</p>
<p>The actual values assigned to each spatial unit are randomized
repeatedly – the values are moved to a randomly-designated spatial unit
– to create a distribution that we use for our hypothesis test. The
expected value of <span class="math inline">\(I\)</span> for that
“theoretical” distribution approaches <span
class="math inline">\(0\)</span> as the number of spatial units
increases, and the standard deviation of the sampling distribution can
only be derived once <span class="math inline">\(W_{ij}\)</span> has
been created.</p>
<p>What this essentially means is that we’re comparing our measured
values against a “hypothetical distribution” in which those values are
distributed randomly across space.</p>
<p>For example, the top map shows a variable that is randomly
distributed across space, and the bottom map shows one that likely is
spatially autocorrelated:</p>
<p><img src="img/R%20Module%209/moran.png" width="50%" style="display: block; margin: auto;" /></p>
<p>This is the null hypothesis associated with Moran’s I: spatial
randomness. If the variable in question doesn’t spatially autocorrelate
(i.e., it doesn’t differ significantly from a hypothetical random
spatial distribution), we do not reject the null. However, if the
variable does autocorrelate and our <span
class="math inline">\(p\)</span>-values are less than our <span
class="math inline">\(\alpha\)</span> (usually 0.05), then we reject the
null hypothesis and can confidently state that our variable spatially
autocorrelates.</p>
<p>More formally, our null hypothesis is that our calculated <span
class="math inline">\(I\)</span> is equal to the expected <span
class="math inline">\(I \approx 0\)</span>. The alternative hypothesis
is that the calculated <span class="math inline">\(I \neq\)</span> the
expected <span class="math inline">\(I\)</span>. Thus, we have a
two-tailed test.</p>
<hr />
</div>
</div>
<div id="performing-the-morans-i-calculation" class="section level1">
<h1>Performing the Moran’s I Calculation</h1>
<p>Let’s try this on the variable for manufacturing jobs in the year
2000, <code>MNEM2000</code>:</p>
<pre class="r"><code>moran.test(
  x = NC_UTM$MNEM2000,
  listw = queen_nb_w,
  zero.policy = TRUE,
  alternative = &quot;two.sided&quot;
)</code></pre>
<pre><code>## 
##  Moran I test under randomisation
## 
## data:  NC_UTM$MNEM2000  
## weights: queen_nb_w    
## 
## Moran I statistic standard deviate = 6.2869, p-value = 3.239e-10
## alternative hypothesis: two.sided
## sample estimates:
## Moran I statistic       Expectation          Variance 
##       0.388470385      -0.010101010       0.004019201</code></pre>
<p>The calculated Moran’s I is listed (as <code>statistic</code>) along
with the expected value of the “hypothetical” sampling distribution (as
<code>Expectation</code>), as well as the <span
class="math inline">\(p\)</span>-value. The expected value is around
-0.01, and the calculated <span class="math inline">\(I\)</span> of
0.3884 is <strong>not</strong> close to the expected value (which should
be close to 0). Unsurprisingly, our <span
class="math inline">\(p\)</span>-value is also fairly low, at <span
class="math inline">\(3.239\times 10^{-10}\)</span>.</p>
<p>This means than using a sampling distribution created by
randomization and a row-standardized Queen’s case spatial weights
matrix, we would have much less than a 1% chance of making a Type-I
error if we reject our null hypothesis (of no spatial autocorrelation).
We can confidently say, therefore, that <code>MNEM2000</code> is a
spatially autocorrelated variable.</p>
<div id="questions" class="section level2">
<h2>Questions</h2>
<p><strong>1. Calculate Moran’s I for the following variables in the
dataset. List the Moran’s I values and p-values for each variable in a
single summary table:</strong></p>
<ul>
<li><code>MNEM2000</code></li>
<li><code>MNEM1990</code></li>
<li><code>TOTJOB2000</code></li>
<li><code>TOTJOB1990</code></li>
</ul>
<p><strong>Provide your R code for the Moran’s I tests (not the results
themselves – that’s what the table is for).</strong></p>
<hr />
</div>
</div>
<div id="spatial-weights-matrix" class="section level1">
<h1>Spatial Weights Matrix</h1>
<p>To better ensure our results are accurate, it’s important to test
other neighborhood criteria. Because our spatial weights matrix is used
to calculate Moran’s I, our result could simply be due to the choice of
neighborhood criterion. What if we used a different neighborhood
construct? Let’s try with a Rook’s case, row-standardized as normal:</p>
<pre class="r"><code>rook_nb_w &lt;- NC_UTM %&gt;%
  tibble::column_to_rownames(&quot;NAME&quot;) %&gt;%
  st_as_sf() %&gt;%
  poly2nb(queen = F) %&gt;%
  nb2listw(
    style = &quot;W&quot;,
    zero.policy = TRUE
  )

moran.test(
  x = NC_UTM$MNEM2000,
  listw = rook_nb_w,
  zero.policy = T,
  alternative = &quot;two.sided&quot;
)</code></pre>
<pre><code>## 
##  Moran I test under randomisation
## 
## data:  NC_UTM$MNEM2000  
## weights: rook_nb_w    
## 
## Moran I statistic standard deviate = 6.3762, p-value = 1.815e-10
## alternative hypothesis: two.sided
## sample estimates:
## Moran I statistic       Expectation          Variance 
##       0.404484123      -0.010101010       0.004227639</code></pre>
<p>Did anything change? It looks like our <span
class="math inline">\(I\)</span> changed slightly, but our <span
class="math inline">\(p\)</span>-value is still significant at <span
class="math inline">\(\alpha = 0.05\)</span>, but suggests that our
Moran’s I can be sensitive to changes in our spatial weights matrix.</p>
<div id="questions-1" class="section level2">
<h2>Questions</h2>
<p><strong>2. Calculate Moran’s I for the <code>MNEM2000</code> variable
using four different versions of <span
class="math inline">\(W_{ij}\)</span>:</strong></p>
<ul>
<li>Queen’s Case</li>
<li>Rook’s Case</li>
<li><span class="math inline">\(k = 4\)</span> nearest neighbors</li>
<li>Maximum Distance (100% threshold)</li>
</ul>
<p><strong>Make sure your weights matrices are row standardized. Provide
a table that summarized the calculated I, <span
class="math inline">\(p\)</span>-values, and average number of
connections per county. Discuss any systematic changes you observe in I,
<span class="math inline">\(p\)</span>-values, and average
links.</strong></p>
<hr />
<hr />
</div>
</div>
<div id="spatial-correlogram" class="section level1">
<h1>Spatial Correlogram</h1>
<p>If we want to explore how spatial autocorrelation changes over
distance, we can create a spatial correlogram. This is a graph with a
measure of spatial autocorrelation on the y axis and the different
distance-based or boundary-based “bands” on the x axis. Consider the
example of a Queen’s case spatial weights matrix: we could also define
“2<sup>nd</sup>-order neighbors”; these would be the neighbors to the
original neighbors. For example:</p>
<p><img src="img/R%20Module%209/neighbors.png" width="40%" style="display: block; margin: auto;" /></p>
<p>The correlogram calculates Moran’s I at these different orders,
called “lags”, to assess how spatial autocorrelation varies across
distance. When you create the correlogram, you need to specify how many
lags you want, and which autocorrelation test to perform (we’ll use
Moran’s I).</p>
<p>Let’s do this for our <code>MNEM2000</code> variable using a Queen’s
case <span class="math inline">\(W_{ij}\)</span> and 4 lags. In this
function, we specify the <strong>non-weighted</strong> neighbor object
(<code>queen_nb</code>, not <code>queen_nb_w</code>), the number of lags
(4), and that we’re using Moran’s I for our test:</p>
<pre class="r"><code>corr_gram &lt;- sp.correlogram(
  neighbours = queen_nb,
  var = NC_UTM$MNEM2000,
  order = 4,
  method = &quot;I&quot;,
  style = &quot;W&quot;,
  zero.policy = TRUE
)


plot(corr_gram)</code></pre>
<p><img src="RModule9_files/figure-html/correlogram-1-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>What this is telling us is that the manufacturing count for a given
county is similar to its neighboring counties and less similar the
further away these counties are. If we were to plot more lags, we might
see Moran’s I rise again. If so, this would indicate that there was a
significant distance between manufacturing centers within the state,
something suggested by our previous results.</p>
<div id="questions-2" class="section level2">
<h2>Questions</h2>
<p><strong>3. Create and provide the spatial correlogram plots for the
<code>MNEM2000</code> variable, using the Queen’s case, Rook’s case,
<span class="math inline">\(k = 4\)</span> nearest neighbors, and
Maximum Distance spatial weights matrices. Make sure to label the plots!
What is the general relationship between manufacturing and distance that
can be derived from these plots?</strong></p>
<hr />
<hr />
</div>
</div>
<div id="local-morans-i" class="section level1">
<h1>Local Moran’s I</h1>
<p>The <em>global</em> Moran’s I provides a single statistic that
describes the “overall” spatial autocorrelation of a variable, but
doesn’t actually tell us <em>where</em> we find clustering among our
spatial units. Another consideration is that there is a specific set or
region of spatial units that are contributing to a significant global
Moran’s I value; for example, perhaps <code>MNEM2000</code> is only
autocorrelated in the Piedmont region, or in the peripheries, etc.</p>
<p>To address these questions, we need a <strong>Local Indicator of
Spatial Autocorrelation</strong> (LISA). The “local Moran’s I” is
exactly such a statistic, and it returns a value for each area or point
using our <span class="math inline">\(W_{ij}\)</span> to define the
neighborhood around each area or point.</p>
<p>As shown below, the formula to calculate the local Moran’s I is
different the the formula we saw earlier:</p>
<p><span class="math inline">\(I_i = z_i \sum_j W_{ij} z_j\)</span>,
where <span class="math inline">\(z_i\)</span> and <span
class="math inline">\(z_j\)</span> represent the deviations from the
mean.</p>
<p>Rather than summarize spatial autocorrelation into a single value,
local Moran’s I assigns a measure of spatial autocorrelation to each
spatial unit. It does this by calculating the average value of the
variable, for example <code>MNEM2000</code>, among neighboring units,
which is called the lag variable. Then, the value of each lag is
compared to the value in the focal unit; if the value in the lag is
similar to the value of the focal unit, we have positive local spatial
autocorrelation.</p>
<p>This process is repeated for every spatial unit in the data,
resulting in new localized measures. Because we will have a measure for
every unit, we can explore the resulting patterns using scatter plots
and maps. We won’t have a single <span
class="math inline">\(p\)</span>-value either; instead, we’ll have a
<span class="math inline">\(p\)</span>-value for each
‘neighborhood’.</p>
<hr />
<div id="calculating-local-morans-i" class="section level2">
<h2>Calculating Local Moran’s I</h2>
<p>To calculate Local Moran’s I, we’ll use the <code>localmoran()</code>
function from <code>spdep</code>. Just as with the global Moran’s I, we
have to specify both the variable to test and the <span
class="math inline">\(W_{ij}\)</span> to use. Let’s use
<code>MNEM2000</code> again, and the Queen’s case matrix.</p>
<pre class="r"><code>local_moran_queen &lt;- localmoran(
  x = NC_UTM$MNEM2000,
  listw = queen_nb_w,
  # zero.policy = TRUE,
  alternative = &quot;two.sided&quot;
)

head(local_moran_queen)</code></pre>
<pre><code>##                      Ii         E.Ii     Var.Ii       Z.Ii Pr(z != E(Ii))
## Ashe        0.224968418 -0.002784784 0.09067850 0.75633175      0.4494503
## Alleghany   0.006921914 -0.005258719 0.17081028 0.02947222      0.9764880
## Surry       0.073576987 -0.001178770 0.02258649 0.49741664      0.6188953
## Currituck   0.660771648 -0.006634965 0.32618436 1.16858131      0.2425724
## Northampton 0.386756847 -0.004588473 0.11068999 1.17626713      0.2394881
## Hertford    0.448120266 -0.004260557 0.13852749 1.21544748      0.2241955</code></pre>
<p>What does this tell us? Call <code>?localmoran</code> to get an
explanation as to each column.</p>
<p>Just like regression residuals, we can explore these local measures
with a scatter plot and a map. Let’s start with a scatterplot of the
actual manufacturing counts for each county against the lag counts for
each county:</p>
<pre class="r"><code>moran.plot(
  x = NC_UTM$MNEM2000,
  listw = queen_nb_w,
  labels = NC_UTM$NAME,
  xlab = &quot;Manufacturing Counts&quot;,
  ylab = &quot;Lag Manufacturing Counts&quot;
)</code></pre>
<p><img src="RModule9_files/figure-html/loc-moran-scatter-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>This plot shows us quite a bit of information. First, we should note
that the mean values of both our manufacturing counts and the lag
manufacturing counts (average counts from each county’s neighbors) are
shown by the dashed lines. This allows us to break up the plot into four
quadrants:</p>
<ol style="list-style-type: decimal">
<li>The upper left quadrant shows us counties with counts below the
mean, surrounded by counties above the mean.</li>
<li>The upper right shows high-count counties surrounded by high-count
counties.</li>
<li>The lower left is the “low-low” counties.</li>
<li>The lower right is the “high-low” counties.</li>
</ol>
<p>It’s important to note that the way each county is assigned is
dependent on our significance level; right now it’s still <span
class="math inline">\(\alpha = 0.05\)</span>. Counties on the above
scatter plot with the ‘diamond’ symbol are those where the <span
class="math inline">\(p\)</span>-value is less than our significance
level. If we change our significance level to say, 50%, we can see more
of the distribution (but of course, our results are not nearly as
significant)</p>
<pre class="r"><code>quadr &lt;- attr(local_moran_queen, &quot;quadr&quot;)[, 2]

NC_localmoran &lt;- NC_UTM

NC_localmoran$Quadrant &lt;- quadr

NC_localmoran$p.value &lt;- local_moran_queen[, 5]

sig_level &lt;- 0.5

NC_localmoran &lt;- NC_localmoran %&gt;%
  mutate(
    Quadrant_Sig = if_else(
      p.value &lt;= sig_level,
      true = as.character(Quadrant),
      false = &quot;Insignificant&quot;
    ) %&gt;%
      as.factor()
  )</code></pre>
<p>Let’s plot this with a color palette to highlight where there are
significant levels of local spatial autocorrelation:</p>
<pre class="r"><code>lm_pal &lt;-
  c(
    &quot;High-High&quot; = &quot;red&quot;,
    &quot;High-Low&quot; = &quot;#FF000080&quot;,
    &quot;Insignificant&quot; = &quot;gray90&quot;,
    &quot;Low-High&quot; = &quot;#0000FF80&quot;,
    &quot;Low-Low&quot; = &quot;blue&quot;
  )


tm_shape(NC_localmoran) +
  tm_polygons(
    col = &quot;Quadrant_Sig&quot;,
    palette = lm_pal,
    border.col = &quot;black&quot;
  ) +
  tm_layout(
    main.title = paste0(&quot;LISA Cluster at Alpha = &quot;, sig_level)
    
  )</code></pre>
<p><img src="RModule9_files/figure-html/local-moran-map-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>This map shows the four different types of clusters. Many counties
fall into either the <code>High-High</code> or <code>Low-Low</code>
categories. However, these results are based on a very high value of
alpha; what happens if we restrict alpha to a more conventional
level?</p>
</div>
<div id="questions-3" class="section level2">
<h2>Questions</h2>
<p><strong>4. Adopt the code above to provide LISA maps for the
<code>MNEM1990</code> variable at an alpha of 0.1, 0.05, and 0.01 using
the Queen’s case W. Provide a brief explanation of your findings about
any local spatial autocorrelation at these more restrictive values of
alpha.</strong></p>
<hr />
<p>Congratulations on completing this R Module; there was certainly a
LOT to cover here!</p>
</div>
</div>

<p>&copy; 2022 Maggie Sugg & Harrison Brown. v.0.0.12</p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
