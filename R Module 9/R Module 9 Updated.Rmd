---
title: "R Module 9"
author: "Harrison Brown"
date: "`r Sys.Date()`"
output: pdf_document
toc: true
---

```{=html}
<style>
body{
  text-align: justify
}
</style>
```

------------------------------------------------------------------------

\pagebreak

# Data Setup

```{r setup, include=FALSE}
library(tint)
library(sf)
library(dplyr)
library(ggplot2)
library(spdep)
library(cowplot)
NC <-
  st_read("C:/Users/brownhr/Documents/R Projects/Data/NC_REGION.shp")
NC <- NC %>% rename(TOTJOB1990 = TOTJO1990)
# invalidate cache when the package version changes
knitr::opts_chunk$set(echo = TRUE)
```

```{r utm}
# Reproject the shapefile into UTM, a projected CRS
NC_utm <- st_transform(NC, st_crs(26917))
# Find centroids of each polygon
centroids <- NC_utm %>%
  st_geometry() %>%
  st_centroid()
```

```{r neighbors}
# Calculate neighbors using Queen's rule
NC_queen <- poly2nb(pl = NC_utm,
                    row.names = NC_utm$NAME,
                    queen = TRUE)
NC_rook <- poly2nb(pl = NC_utm,
                   row.names = NC_utm$NAME,
                   queen = FALSE)
NC_k4 <- knn2nb(knearneigh(centroids, k = 4))
# Calculate max distance for dnearneigh
max.dist <- knn2nb(knearneigh(centroids, k = 1)) %>%
  nbdists(coords = centroids) %>%
  unlist() %>% max()
NC_d100 <- dnearneigh(x = centroids, d1 = 0, d2 = max.dist)
# Convert to weights list object
NC_queen_listw <- nb2listw(NC_queen)
NC_rook_listw <- nb2listw(NC_rook)
NC_k4_listw <- nb2listw(NC_k4)
NC_d100_listw <- nb2listw(NC_d100)
```

\pagebreak

# Analysis

```{r moran-1}
moran_MNEM2000 <- moran.test(
  x = NC_utm$MNEM2000,
  listw = NC_queen_listw,
  alternative = "two.sided",
  zero.policy = TRUE
)
```

Measuring Moran's I for Manufacturing Jobs gives a statistic of **`r moran_MNEM2000$estimate["Moran I statistic"]`** and a p-value of `r moran_MNEM2000$p.value`, indicating that there is somewhat strong positive spatial autocorrelation.

## 1. Moran's I for Numeric Variables in NC

The variables in this analysis are `MNEM1990`, `MNEM2000`, `TOTJOB1990`, and `TOTJOB2000`.

```{r variables}
vars <- list(MNEM1990 = "MNEM1990",
             MNEM2000 = "MNEM2000",
             TOTJOB1990 = "TOTJOB1990",
             TOTJOB2000 = "TOTJOB2000")
moran.list <- lapply(vars, function(x) {
  data <- NC_utm %>% dplyr::pull(x)
  moran.test(
    x = data,
    listw = NC_queen_listw,
    zero.policy = T,
    alternative = 'two.sided'
  )
})

```

```{r lists}
list.statistics <- data.frame(matrix(ncol = 0, nrow = 4))

list.statistics <- list.statistics %>% 
  mutate(
    Rule = names(vars),
    `Moran's I` = sapply(moran.list, function(x)
      {x$estimate["Moran I statistic"]}),
    `p-value` = sapply(moran.list, function(x)
      {x$p.value}
  ))
```

`r knitr::kable(list.statistics)`

\pagebreak

## 2. Moran's I for different Neighbor Rules

```{r wlist}
w_list <- list(
  Queen = NC_queen_listw,
  Rook = NC_rook_listw,
  `k = 4` = NC_k4_listw,
  `Maximum Distance` = NC_d100_listw
)
moran_diff_w <- lapply(w_list, function(w) {
  moran.test(
    x = NC_utm$MNEM2000,
    listw = w,
    alternative = "two.sided",
    zero.policy = TRUE
  )
})

diff_w_stats <- data.frame(matrix(ncol = 0, nrow = 4))
diff_w_stats <- diff_w_stats %>%
  mutate(
    Rule = names(w_list),
    `Moran's I` = sapply(moran_diff_w, function(x) {
      x$estimate["Moran I statistic"]
    }),
    `p-value` = sapply(moran_diff_w, function(x) {
      x$p.value
    }),
    `Avg. Neighbors` = sapply(w_list, function(x) {
      y <- x$neighbours
      len <- sapply(y, length)
      mean(len)
    })
  )
```

`r knitr::kable(diff_w_stats)`

I found it interesting that the Moran's I for the Rook and k = 4 cases were so similar; this might be because Rook searches for neighbors in four directions.

\pagebreak

## 3. Spatial Correlogram Plots

```{r plotcor, echo = F}
pal <- c("#9C4F96",
         "#FF6355",
         "#FBA949",
         "#E1CD3B",
         "#8BD448",
         "#2AA8F2",
         "violet")
cor_list_nb <- list(
  Queen = NC_queen,
  Rook = NC_rook,
  `k = 4` = NC_k4,
  `Maximum Distance` = NC_d100
)
cor_gram_list <- lapply(cor_list_nb, function(nb) {
  sp.correlogram(
    neighbours = nb,
    NC_utm$MNEM2000,
    order = 7,
    method = "I",
    style = "W",
    zero.policy = T
  )
})
cor.df <- mapply(SIMPLIFY = F, function(x, n) {
  d <- x$res %>% as.data.frame() %>%
    rename(Estimate = V1,
           Expectiation = V2,
           Variance = V3) %>%
    mutate(
      min = -2 * sqrt(Variance) + Estimate,
      max = 2 * sqrt(Variance) + Estimate,
      Rule = n
    ) %>% tibble::rownames_to_column(var = "Lag")
}, cor_gram_list, names(cor_gram_list))
cor_gg_list <- mapply(SIMPLIFY = F, function(x, r) {
  ggplot(x, aes(
    x = Lag %>% as.numeric(),
    y = Estimate,
    ymin = min,
    ymax = max
  )) +
    geom_point(size = 2, color = "#FF6355") +
    geom_errorbar(width = .2, color = "#FF6355") +
    labs(y = "Estimate",
         x = "Lag",
         title = as.character(r)) +
    theme(
      legend.position = "null",
      plot.title = element_text(hjust = .5),
      text = element_text(family = "serif")
    ) +
    ylim(-.3, .7)
}, cor.df, names(cor.df))
cowplot::plot_grid(plotlist = cor_gg_list, align = "hv")

```

The general spatial pattern with MNEM2000 is that counties become less similar the further out, but around order \~ 4, there is a small "bump", showing that clusters have a significant distance between clusters. Interestingly, the estimate drops below 0 for most of the models, indicating there is a slight negative spatial autocorrelation at large scales (lags) -- this could represent clusters of manufacturing jobs being surrounded by areas with far fewer jobs, and shows how industrial centers "clump" together. From a business standpoint, it would not make sense to build factories very close together, but rather provide access to a greater geographic area.

\pagebreak

## 4. LISA

```{r lisa-quadrant}
localMoran.queen <- localmoran(NC_utm$MNEM2000, NC_queen_listw)

sig <- c(.5, .1, .05, .01)


NC_utm <- NC_utm %>%
  mutate(Significance = localMoran.queen[,5],
         Quadrant_name = attr(localMoran.queen, "quadr")$mean,
         Quadrant = data.table::fifelse((Significance > sig),
                            "Insignificant", 
                            Quadrant_name %>% as.character()))
         

```

```{r lisa-plot, echo = F}
sig.colors <- c(
    "Low-Low" = "#1030f7",
    "Low-High" = "#8f7efe",
    "Insignificant" = "#EEEEEE",
    "High-Low" = "#e98ddb",
    "High-High" = "#fC0233"
  ) %>% rev()

ggplot(NC_utm, aes(fill = factor(Quadrant))) + 
  geom_sf() + 
  scale_fill_manual(values = sig.colors)
```
